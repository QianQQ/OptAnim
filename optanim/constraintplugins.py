from constraint import *
from utils import *

class ConstraintPlugin(object):
    '''Abstract base class for constraint plugins. Constraint plugins provide a
    way to specify constraints that will perform the same function for any
    character, regardless of particular morphologies'''

    def __init__(self):
	pass

    def get_constraints(self, animation, character): abstract
    '''Returns a list of constraints generated by the plugin'''


class ConstraintPluginLoop(ConstraintPlugin):
    '''A constraint plugin that enforces cyclic (looping) motion'''

    def __init__(self, vel=[0]*dof, angVel=[0]*3):
	'''Constructor'''
	self.vel = vel
	self.angVel = angVel
	ConstraintPlugin.__init__(self)

    def get_offset(self, qin, dir):
	'''Returns q coordinates transformed in dir direction (+1 / -1). This
	is a fairly arbitrary transform (but expressive enough for making
	characters move in a variety of ways)'''
	q = list(qin)

	if self.angVel[0] is not 0 or self.angVel[1] is not 0 or self.angVel[2] is not 0:
	    #rotate body positions around a point
	    rotCenterWorld = sympy.Matrix([0,0,0]) #rotation (pivot) point; just the origin for now
	    rotmat = euler_to_matrix([dir*k*self.animation.Length for k in self.angVel])
	    q[:3] = (rotmat * (sympy.Matrix(q[:3]) - rotCenterWorld)) + rotCenterWorld
	    
	    #also the bodies themselves rotate:
	    if self.angVel[0] is 0 and self.angVel[2] is 0:
		#special performance tweak for rotation only around y-axis:
		#this works because our rotation order is YXZ (y first)
		q[4] = q[4]+(dir*self.angVel[1]*self.animation.Length)
	    else:
		#generic method, always works
		currRotMat = euler_to_matrix(q[3:])
		newRotMat = (rotmat*currRotMat)
		q[3:] = matrix_to_euler(newRotMat)

	#finally we add a simple offset to body positions and rotations
	q = [x+(dir*self.vel[k]*self.animation.Length) for k,x in enumerate(q)]

	return q

    def get_constraints(self, animation, character):
	self.animation = animation  #TODO: HACK: save a reference for later reference in get_offset
	retList = []

	#first frame connects to last
	retList.extend(character.get_newtonian_constraints(
	    'LoopBegin', 'pTimeEnd', 'pTimeBegin', 'pTimeBegin+1', 't=pTimeBegin', self.get_offset, -1, None, 1))

	#last frame connects to first
	retList.extend(character.get_newtonian_constraints(
	    'LoopEnd', 'pTimeEnd-1', 'pTimeEnd', 'pTimeBegin', 't=pTimeEnd', None, -1, self.get_offset, 1))

	#we also have to loop the contact joint 'zero velocity' constraints
	for j in character.get_joints_contact():
	    tRangeOn = 't in sTimeSteps_' + j.Name + 'On'
	    begin = self.get_offset([x('pTimeBegin') for x in j.Body.q], 1)
	    end = [x('pTimeEnd') for x in j.Body.q]

	    worldpoint_Begin = list(world_xf(j.Point, begin))
	    worldpoint_End = list(world_xf(j.Point, end))

	    #loop the contact joint 'zero velocity' constraints (see joints.py)
	    retList.append(ConstraintEq(j.Name + '_state_x_loop', worldpoint_Begin[0], worldpoint_End[0], TimeRange=tRangeOn + ' && t=pTimeBegin'))
	    retList.append(ConstraintEq(j.Name + '_state_z_loop', worldpoint_Begin[2], worldpoint_End[2], TimeRange=tRangeOn + ' && t=pTimeBegin'))

	    #loop the contact joint 'zero angular velocity' constraint (see joints.py)
	    retList.append(ConstraintEq(j.Name + '_state_ry_loop', begin[4], end[4], TimeRange=tRangeOn + ' && t=pTimeBegin'))

	return retList


class ConstraintPluginGroundPlane(ConstraintPlugin):
    '''A constraint plugin that keeps bodies on or above the ground plane'''

    def __init__(self):
	'''Constructor'''
	ConstraintPlugin.__init__(self)

    def get_constraints(self, animation, character):
	retList = []
	for body in character.BodyList:
	    worldpointA = world_xf(body.ep_a(), [bq(t) for bq in body.q])
	    worldpointB = world_xf(body.ep_b(), [bq(t) for bq in body.q])
	    retList.append(Constraint(body.Name + '_AboveGroundPlane_A', lb=0, c=worldpointA[1]))
	    retList.append(Constraint(body.Name + '_AboveGroundPlane_B', lb=0, c=worldpointB[1]))
	return retList